// Code generated by MockGen. DO NOT EDIT.
// Source: awsapis/ec2.go

// Package mock_awsapis is a generated GoMock package.
package mock_awsapis

import (
	context "context"
	reflect "reflect"

	ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"
	gomock "go.uber.org/mock/gomock"
)

// MockEc2Api is a mock of Ec2Api interface.
type MockEc2Api struct {
	ctrl     *gomock.Controller
	recorder *MockEc2ApiMockRecorder
}

// MockEc2ApiMockRecorder is the mock recorder for MockEc2Api.
type MockEc2ApiMockRecorder struct {
	mock *MockEc2Api
}

// NewMockEc2Api creates a new mock instance.
func NewMockEc2Api(ctrl *gomock.Controller) *MockEc2Api {
	mock := &MockEc2Api{ctrl: ctrl}
	mock.recorder = &MockEc2ApiMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEc2Api) EXPECT() *MockEc2ApiMockRecorder {
	return m.recorder
}

// DescribeSubnets mocks base method.
func (m *MockEc2Api) DescribeSubnets(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeSubnets", varargs...)
	ret0, _ := ret[0].(*ec2.DescribeSubnetsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeSubnets indicates an expected call of DescribeSubnets.
func (mr *MockEc2ApiMockRecorder) DescribeSubnets(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeSubnets", reflect.TypeOf((*MockEc2Api)(nil).DescribeSubnets), varargs...)
}

// TerminateInstances mocks base method.
func (m *MockEc2Api) TerminateInstances(ctx context.Context, params *ec2.TerminateInstancesInput, optFns ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TerminateInstances", varargs...)
	ret0, _ := ret[0].(*ec2.TerminateInstancesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TerminateInstances indicates an expected call of TerminateInstances.
func (mr *MockEc2ApiMockRecorder) TerminateInstances(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TerminateInstances", reflect.TypeOf((*MockEc2Api)(nil).TerminateInstances), varargs...)
}

// MockEc2SubnetsDescriptor is a mock of Ec2SubnetsDescriptor interface.
type MockEc2SubnetsDescriptor struct {
	ctrl     *gomock.Controller
	recorder *MockEc2SubnetsDescriptorMockRecorder
}

// MockEc2SubnetsDescriptorMockRecorder is the mock recorder for MockEc2SubnetsDescriptor.
type MockEc2SubnetsDescriptorMockRecorder struct {
	mock *MockEc2SubnetsDescriptor
}

// NewMockEc2SubnetsDescriptor creates a new mock instance.
func NewMockEc2SubnetsDescriptor(ctrl *gomock.Controller) *MockEc2SubnetsDescriptor {
	mock := &MockEc2SubnetsDescriptor{ctrl: ctrl}
	mock.recorder = &MockEc2SubnetsDescriptorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEc2SubnetsDescriptor) EXPECT() *MockEc2SubnetsDescriptorMockRecorder {
	return m.recorder
}

// DescribeSubnets mocks base method.
func (m *MockEc2SubnetsDescriptor) DescribeSubnets(ctx context.Context, params *ec2.DescribeSubnetsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSubnetsOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeSubnets", varargs...)
	ret0, _ := ret[0].(*ec2.DescribeSubnetsOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeSubnets indicates an expected call of DescribeSubnets.
func (mr *MockEc2SubnetsDescriptorMockRecorder) DescribeSubnets(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeSubnets", reflect.TypeOf((*MockEc2SubnetsDescriptor)(nil).DescribeSubnets), varargs...)
}

// MockEc2InstanceTerminator is a mock of Ec2InstanceTerminator interface.
type MockEc2InstanceTerminator struct {
	ctrl     *gomock.Controller
	recorder *MockEc2InstanceTerminatorMockRecorder
}

// MockEc2InstanceTerminatorMockRecorder is the mock recorder for MockEc2InstanceTerminator.
type MockEc2InstanceTerminatorMockRecorder struct {
	mock *MockEc2InstanceTerminator
}

// NewMockEc2InstanceTerminator creates a new mock instance.
func NewMockEc2InstanceTerminator(ctrl *gomock.Controller) *MockEc2InstanceTerminator {
	mock := &MockEc2InstanceTerminator{ctrl: ctrl}
	mock.recorder = &MockEc2InstanceTerminatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEc2InstanceTerminator) EXPECT() *MockEc2InstanceTerminatorMockRecorder {
	return m.recorder
}

// TerminateInstances mocks base method.
func (m *MockEc2InstanceTerminator) TerminateInstances(ctx context.Context, params *ec2.TerminateInstancesInput, optFns ...func(*ec2.Options)) (*ec2.TerminateInstancesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TerminateInstances", varargs...)
	ret0, _ := ret[0].(*ec2.TerminateInstancesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TerminateInstances indicates an expected call of TerminateInstances.
func (mr *MockEc2InstanceTerminatorMockRecorder) TerminateInstances(ctx, params interface{}, optFns ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TerminateInstances", reflect.TypeOf((*MockEc2InstanceTerminator)(nil).TerminateInstances), varargs...)
}
